package vervet

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/fs"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/ghodss/yaml"
)

// ToSpecJSON renders an OpenAPI document object as JSON.
func ToSpecJSON(v interface{}) ([]byte, error) {
	return json.MarshalIndent(v, "", "  ")
}

// ToSpecYAML renders an OpenAPI document object as YAML.
func ToSpecYAML(v interface{}) ([]byte, error) {
	jsonBuf, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal JSON: %w", err)
	}
	yamlBuf, err := yaml.JSONToYAML(jsonBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal YAML: %w", err)
	}
	return WithGeneratedComment(yamlBuf)
}

// WithGeneratedComment prepends a comment to YAML output indicating the file
// was generated.
func WithGeneratedComment(yamlBuf []byte) ([]byte, error) {
	var buf bytes.Buffer
	_, err := fmt.Fprintf(&buf, "# OpenAPI spec generated by vervet, DO NOT EDIT\n")
	if err != nil {
		return nil, fmt.Errorf("failed to write output: %w", err)
	}
	_, err = buf.Write(yamlBuf)
	if err != nil {
		return nil, fmt.Errorf("failed to write output: %w", err)
	}
	return buf.Bytes(), nil
}

// LoadVersions loads all Vervet-compiled and versioned API specs from a
// filesystem root and returns them.
func LoadVersions(root fs.FS) ([]*openapi3.T, error) {
	var versions []*openapi3.T
	specFiles, err := fs.Glob(root, "*/spec.json")
	if err != nil {
		return nil, err
	}
	for _, specFile := range specFiles {
		specData, err := fs.ReadFile(root, specFile)
		if err != nil {
			return nil, err
		}
		l := openapi3.NewLoader()
		t, err := l.LoadFromData(specData)
		if err != nil {
			return nil, err
		}
		if _, err := ExtensionString(t.Extensions, ExtSnykApiVersion); IsExtensionNotFound(err) {
			// Not a versioned OpenAPI spec, skip it
			continue
		} else if err != nil {
			return nil, err
		}
		versions = append(versions, t)
	}
	if len(versions) == 0 {
		return nil, ErrNoMatchingVersion
	}
	return versions, nil
}
